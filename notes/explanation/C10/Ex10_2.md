```java
/**
 * Adjust previous solution in such a way that you limit rate of requests. Number of requested messages stays the
 * same, but each request should be limited to 1 message.
 */
@Test
public void limited_demand() {
  CopyOnWriteArrayList<Long> requests = new CopyOnWriteArrayList<>();
  Flux<String> messageStream = messageStream2()
          .doOnRequest(requests::add)
          .limitRate(1);

  StepVerifier.create(messageStream, StepVerifierOptions.create().initialRequest(0))
          .expectSubscription()
          .thenRequest(1)
          .then(() -> pub2.next("msg#1"))
          .thenRequest(3)
          .then(() -> pub2.next("msg#2", "msg#3"))
          .then(pub2::complete)
          .expectNext("msg#1", "msg#2", "msg#3")
          .verifyComplete();

  Assertions.assertEquals(List.of(1L, 1L, 1L, 1L), requests);
}
```

У цьому коді перевіряється, як працює управління швидкістю запитів (rate limiting) в асинхронному потоці даних за допомогою бібліотеки Project Reactor. Ось що відбувається крок за кроком:

### Пояснення Коду

#### Контекст

Ми маємо `Flux<String>`, який представляє асинхронний потік повідомлень. Ми хочемо перевірити, що з потоку запитуються повідомлення по одному за раз, навіть якщо Publisher надсилає більше повідомлень.

#### Опис Коду

1. **`requests`**: Це список, який буде використовуватися для зберігання кількості запитів, які надіслано до Publisher. Використовується `CopyOnWriteArrayList` для забезпечення потокобезпеки.

    ```java
    CopyOnWriteArrayList<Long> requests = new CopyOnWriteArrayList<>();
    ```

2. **`messageStream`**: Це ваш основний потік даних (`Flux`), який отримує повідомлення з `messageStream2()`. Метод `doOnRequest(requests::add)` додає кількість запитів до списку `requests` щоразу, коли запит надсилається до Publisher. Оператор `limitRate(1)` обмежує запити до 1 елемента за раз.

    ```java
    Flux<String> messageStream = messageStream2()
            .doOnRequest(requests::add)
            .limitRate(1);
    ```

3. **`StepVerifier.create(...)`**: Це інструмент для тестування асинхронних потоків даних в Project Reactor. У цьому випадку, він перевіряє поведінку `messageStream`.

    ```java
    StepVerifier.create(messageStream, StepVerifierOptions.create().initialRequest(0))
    ```

  - **`initialRequest(0)`**: Споживач починає з нульової кількості запитів, що означає, що не буде одразу запитуватись жодне повідомлення.

4. **`thenRequest(1)`**: Після підписки, споживач запитує 1 елемент.

    ```java
    .thenRequest(1)
    ```

5. **`then(() -> pub2.next("msg#1"))`**: Мок-оператор для симуляції надходження одного повідомлення `"msg#1"` до Publisher `pub2`.

    ```java
    .then(() -> pub2.next("msg#1"))
    ```

6. **`thenRequest(3)`**: Після отримання першого повідомлення, споживач запитує ще 3 елементи.

    ```java
    .thenRequest(3)
    ```

7. **`then(() -> pub2.next("msg#2", "msg#3"))`**: Мок-оператор для симуляції надходження двох нових повідомлень `"msg#2"` і `"msg#3"` до Publisher `pub2`.

    ```java
    .then(() -> pub2.next("msg#2", "msg#3"))
    ```

8. **`then(pub2::complete)`**: Завершення Publisher `pub2`.

    ```java
    .then(pub2::complete)
    ```

9. **`expectNext("msg#1", "msg#2", "msg#3")`**: Перевірка, що споживач отримує повідомлення `"msg#1"`, `"msg#2"`, і `"msg#3"`.

    ```java
    .expectNext("msg#1", "msg#2", "msg#3")
    ```

10. **`verifyComplete()`**: Перевіряє, що Publisher завершився успішно без помилок.

    ```java
    .verifyComplete();
    ```

11. **`Assertions.assertEquals(List.of(1L, 1L, 1L, 1L), requests)`**: Перевіряє, що запити були відправлені по одному за раз. Очікується, що список `requests` міститиме чотири записи, кожен з яких дорівнює 1.

    ```java
    Assertions.assertEquals(List.of(1L, 1L, 1L, 1L), requests);
    ```

### Результат

- **Обмеження запитів**: `limitRate(1)` забезпечує, що споживач запитує лише по одному повідомленню за раз. Таким чином, ви контролюєте швидкість споживання даних.
- **Тестування**: Тест перевіряє, що потік даних працює як очікується, і що запити надходять до Publisher по одному за раз. Це підтверджується переліком запитів (`requests`), який має значення `[1, 1, 1, 1]`.

Цей тест гарантує, що незалежно від того, скільки повідомлень Publisher відправляє, споживач запитує їх по одному, що допомагає уникнути переповнення або надмірного навантаження на систему.

Давайте розглянемо, чому в цьому тесті кількість запитів повинна бути 4.

### Як Працює `limitRate` в Тесті

Оператор `limitRate(1)` забезпечує, що споживач буде запитувати дані по одному елементу за раз, незалежно від того, скільки повідомлень надіслано від Publisher. Це відбувається наступним чином:

1. **Підписка і Початковий Запит**:
   - `StepVerifier.create(messageStream, StepVerifierOptions.create().initialRequest(0))` створює підписку, але не надсилає жодних запитів спочатку (`initialRequest(0)`).
   - Після цього, `.thenRequest(1)` запитує 1 повідомлення.

2. **Отримання Першого Повідомлення**:
   - Як тільки Publisher (`pub2`) надсилає `"msg#1"`, споживач отримує це повідомлення.
   - `requests` додасть 1 до списку запитів, оскільки був запит на 1 елемент.

3. **Другий Запит**:
   - Потім, `.thenRequest(3)` запитує ще 3 елементи.
   - Оскільки `limitRate(1)` обмежує запити до одного елемента за раз, споживач запитує по одному повідомленню з цього запиту.

4. **Отримання Другого і Третього Повідомлень**:
   - Після запиту на 3 елементи, Publisher надсилає `"msg#2"` і `"msg#3"`.
   - Споживач обробляє `"msg#2"` першим, і після цього запитує ще 1 елемент, потім обробляє `"msg#3"`.

### Хронологія Запитів

Ось як відбувається обробка запитів у тесті:

1. **Запит 1**: Споживач запитує 1 повідомлення.
   - `requests` = [1]

2. **Запит 2**: Споживач отримує `"msg#1"`, потім запитує наступне повідомлення.
   - `requests` = [1, 1]

3. **Запит 3**: Споживач отримує `"msg#2"`, потім запитує наступне повідомлення.
   - `requests` = [1, 1, 1]

4. **Запит 4**: Споживач отримує `"msg#3"`, і більше запитів не потрібно, оскільки Publisher завершився.
   - `requests` = [1, 1, 1, 1]

### Підсумок

- **Загальна Кількість Запитів**: 4 запити – один на початку для `"msg#1"`, і три додаткові запити для `"msg#2"` та `"msg#3"` (з кожним запитом по одному елементу).
- **Перевірка `requests`**: Список запитів `[1, 1, 1, 1]` відображає те, що кожен запит був на один елемент, відповідно до налаштувань `limitRate(1)`.

Це підтверджує, що споживач запитував і обробляв повідомлення по одному за раз, як і передбачалося тестом.

Так, вірно. У цьому тесті кількість запитів (requests) була 4, навіть якщо кількість повідомлень (messages) була 3. Це відбувається через те, як працює оператор `limitRate(1)` разом з механізмом запитів.

### Чому Запитів Було Більше

Ось детальне пояснення:

1. **Обмеження Запитів**: `limitRate(1)` обмежує споживача так, що він може запитувати тільки один елемент за раз. Це означає, що навіть якщо споживач запитує 3 елементи за один раз, він буде отримувати їх по одному.

2. **Реакція на Запити**:
   - **Початковий Запит**: Споживач робить перший запит на 1 елемент.
   - **Отримання Повідомлення**: Після отримання повідомлення, споживач робить ще один запит, щоб отримати наступний елемент.
   - **Нове Запитання**: Оскільки `limitRate(1)` обмежує швидкість до одного елемента, після кожного отриманого повідомлення споживач має зробити новий запит для наступного елемента.

3. **Продовження Процесу**:
   - **Перший Запит**: Запит на 1 елемент -> отримано `"msg#1"`.
   - **Другий Запит**: Запит на 1 елемент -> отримано `"msg#2"`.
   - **Третій Запит**: Запит на 1 елемент -> отримано `"msg#3"`.
   - **Четвертий Запит**: Після отримання `"msg#3"`, більше запитів не потрібно, але споживач міг би продовжувати запитувати, якщо Publisher не закінчився.

### Ілюстрація з Тестом

1. **Initial Request**: `StepVerifier` починає без запитів (`initialRequest(0)`).
2. **Request 1**: `thenRequest(1)` запитує 1 елемент.
3. **Request 2**: Після отримання `"msg#1"`, споживач робить наступний запит.
4. **Request 3**: Після отримання `"msg#2"`, споживач робить наступний запит.
5. **Request 4**: Після отримання `"msg#3"`, споживач робить ще один запит, навіть якщо Publisher вже завершився.

Таким чином, через обмеження `limitRate(1)`, споживач робить новий запит після кожного отриманого повідомлення, навіть якщо загальна кількість повідомлень менша ніж кількість запитів.

### Результат

- **Повідомлення**: 3 (`"msg#1"`, `"msg#2"`, `"msg#3"`).
- **Запити**: 4 (по одному запиту на кожне отримане повідомлення, а також для перевірки, що Publisher закінчився).

Тому, в тесті спостерігається 4 запити на 3 повідомлення.