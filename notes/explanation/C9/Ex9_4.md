```java

/**
 * Make task run on thread suited for long, blocking, parallelized work.
 * Answer:
 * - What BlockHound for?
 */
@Test
public void blocking() {
  BlockHound.install(); //don't change this line

  Mono<Void> task = Mono.fromRunnable(ExecutionControlBase::blockingCall)
    .subscribeOn(Schedulers.boundedElastic())
    .then();

  StepVerifier.create(task)
    .verifyComplete();
}
```
### Опис коду

У цьому тесті `blocking()` ви налаштовуєте виконання завдання у середовищі, яке підходить для довготривалої блокуючої роботи, використовуючи `Schedulers.boundedElastic()`. Також використовується інструмент **BlockHound** для виявлення блокуючих викликів.

```java
@Test
public void blocking() {
    BlockHound.install(); //don't change this line

    Mono<Void> task = Mono.fromRunnable(ExecutionControlBase::blockingCall)  // Блокуючий виклик
                          .subscribeOn(Schedulers.boundedElastic())  // Планувальник для блокуючих завдань
                          .then();

    StepVerifier.create(task)  // Перевірка результату
                .verifyComplete();  // Тест на успішне завершення
}
```

### Що тут відбувається:
1. **BlockHound.install()**: BlockHound — це інструмент, який дозволяє виявляти блокуючі виклики у коді, що працює в асинхронних середовищах (таких як Reactor). Його встановлення на початку дозволяє автоматично відслідковувати, чи є у коді блокуючі операції (як-от виклики введення-виведення або синхронні затримки), які можуть спричинити проблеми в реактивних додатках. Якщо блокуючий виклик буде виявлено, BlockHound викине помилку під час виконання.

2. **Mono.fromRunnable(ExecutionControlBase::blockingCall)**: Ви створюєте реактивне джерело типу `Mono`, яке виконує блокуючий метод `blockingCall`. Це завдання буде запускатися в окремому потоці.

3. **subscribeOn(Schedulers.boundedElastic())**: Завдання буде виконуватись на планувальнику `Schedulers.boundedElastic()`, який підходить для довготривалих блокуючих операцій. Це забезпечує, що блокуючі операції не перевантажують ресурси, оскільки цей планувальник обмежує кількість одночасних потоків і створює нові лише тоді, коли це необхідно.

4. **then()**: Оператор `then()` сигналізує про те, що після виконання `blockingCall` не повертається жодного результату, але `Mono` повинен завершитися.

5. **StepVerifier.create(task).verifyComplete()**: За допомогою StepVerifier створюється підписка на `Mono` і перевіряється, що воно завершилось успішно.

### Що таке BlockHound?

**BlockHound** — це інструмент для виявлення блокуючих операцій у реактивних або асинхронних середовищах, таких як Project Reactor. Основна його мета — допомогти розробникам знаходити блокуючі виклики (наприклад, синхронні введення-виведення, виклики до баз даних або файлових систем), які можуть негативно вплинути на продуктивність і асинхронність реактивного застосунку.

**BlockHound** перевіряє, чи викликаються блокуючі операції в потоках, де вони не повинні виконуватися (наприклад, на потоках, призначених для неблокуючої роботи). Якщо такі операції знайдені, він генерує виняток під час виконання, що дозволяє вчасно знайти і виправити проблеми.

### Ключові моменти:
- Використання **`Schedulers.boundedElastic()`** дозволяє обробляти довгі блокуючі операції у спеціальних потоках, не блокуючи основні потоки.
- **BlockHound** допомагає відстежувати блокуючі виклики в неблокуючих середовищах.