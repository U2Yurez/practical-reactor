```java
   /**
 * Adapt code so tasks are executed in parallel, with max concurrency of 3.
 */
@Test
public void free_runners() {
  //todo: feel free to change code as you need
  Mono<Void> task = Mono.fromRunnable(ExecutionControlBase::blockingCall)
    .subscribeOn(Schedulers.boundedElastic())
    .then();

  Flux<Void> taskQueue = Flux.just(task, task, task)
    .flatMap(Function.identity(), 3);

  //don't change code below
  Duration duration = StepVerifier.create(taskQueue)
    .expectComplete()
    .verify();

  Assertions.assertTrue(duration.getSeconds() <= 2, "Expected to complete in less than 2 seconds");
}
```
### Пояснення коду

У цьому тесті **`free_runners()`** ви адаптуєте код, щоб три завдання виконувалися паралельно, але з обмеженням на кількість одночасно виконуваних завдань — максимум 3.

#### Кроки в коді:
1. **Mono.fromRunnable(ExecutionControlBase::blockingCall)**:
    - Створюється `Mono`, яке виконує блокуючий виклик через `ExecutionControlBase::blockingCall`. Завдання виконується на планувальнику `Schedulers.boundedElastic()`, що призначений для довготривалої блокуючої роботи.

2. **subscribeOn(Schedulers.boundedElastic())**:
    - Завдання буде виконуватися на спеціальних потоках, створених для блокуючої роботи, використовуючи `boundedElastic` планувальник. Він дозволяє створювати додаткові потоки в разі потреби, але обмежує їх кількість, щоб уникнути перевантаження.

3. **`Flux<Void> taskQueue = Flux.just(task, task, task)`**:
    - Створюється `Flux`, що містить три однакові завдання, кожне з яких виконується на окремому потоці. У цьому прикладі всі три завдання є посиланнями на один і той самий `Mono`, що представляє блокуючу операцію.

4. **flatMap(Function.identity(), 3)**:
    - Оператор `flatMap` використовується для паралельного виконання завдань із максимальним рівнем одночасності у 3 (параметр `3` означає максимальну кількість одночасно виконуваних завдань). Це забезпечує, що завдання будуть виконуватися паралельно, але не більше ніж 3 одночасно.

5. **StepVerifier.create(taskQueue)**:
    - Створюється підписка на `taskQueue`, і перевіряється, що всі завдання завершилися успішно за допомогою `expectComplete()`.

6. **Duration duration**:
    - Тривалість виконання перевіряється з використанням `StepVerifier`, і перевіряється, що всі завдання завершилися за менше ніж 2 секунди.

#### Основні моменти:
- **`flatMap(Function.identity(), 3)`** дозволяє обмежити кількість одночасно виконуваних завдань до трьох.
- **`Schedulers.boundedElastic()`** підходить для виконання блокуючих завдань, оскільки створює окремі потоки для кожного завдання і керує навантаженням.
- **StepVerifier** дозволяє перевірити, що всі завдання завершились за очікуваний час (у даному випадку менше 2 секунд).

Таким чином, цей тест дозволяє паралельно запускати три завдання з максимальним рівнем одночасності 3, і перевіряє, що вони виконуються за розумний час.

Крок 2:

```java
.subscribeOn(Schedulers.boundedElastic())
```

У цьому випадку, кожне завдання буде виконане на окремому потоці, наданому планувальником `Schedulers.boundedElastic()`.

У зв'язку з тим, що ми використовуємо **`flatMap(Function.identity(), 3)`** з обмеженням на максимальну кількість одночасно виконуваних завдань (3), **крок 2 буде виконаний на трьох окремих потоках** з пулу потоків, який керується `boundedElastic`. Цей планувальник створює нові потоки для блокуючих завдань і обмежує кількість одночасно активних потоків, щоб не перевантажувати систему.

Отже, три завдання будуть виконані паралельно на трьох потоках з пулу потоків `boundedElastic`.