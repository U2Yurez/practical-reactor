```java
    /**
     * Every journey starts with Hello World!
     * As you may know, Mono represents asynchronous result of 0-1 element.
     * Retrieve result from this Mono by blocking indefinitely or until a next signal is received.
     */
    @Test
    public void hello_world() {
        Mono<String> serviceResult = hello_world_service();

        String result = serviceResult.block();

        assertEquals("Hello World!", result);
    }
```
Метод `block()` в Project Reactor використовується для отримання результату з реактивного потоку (`Mono` або `Flux`) синхронно. Ось як він працює:

### Як працює `block()`

1. **Очікування результату:** Коли ви викликаєте `block()` на об'єкті `Mono`, виконується блокування поточного потоку виконання до тих пір, поки не буде отримано значення або не виникне помилка.

2. **Результат:** Якщо `Mono` успішно завершиться і поверне значення, `block()` поверне це значення. Якщо ж виникне помилка, буде викинуто виключення, яке ви можете обробити.

3. **Використання:** Зазвичай `block()` використовується в тестах або в сценаріях, де потрібно отримати результат з асинхронної операції синхронно, наприклад, у простих додатках або для перевірки результатів.

### Приклад

Розглянемо простий приклад:

```java
Mono<String> mono = Mono.just("Hello World!");

// Виклик block()
String result = mono.block(); // Блокує до отримання результату

System.out.println(result); // Виведе "Hello World!"
```

### Особливості

- **Блокування:** Використання `block()` може призвести до блокування потоку, що не є рекомендованою практикою в реактивному програмуванні. Блокування може негативно вплинути на продуктивність і реактивність програми.

- **Тестування:** У тестах `block()` може бути корисним для перевірки результатів асинхронних операцій, але краще використовувати `StepVerifier` для більш чистих і ненаглядних перевірок.

### Висновок

Метод `block()` є простим способом отримання значення з асинхронного потоку, але його слід використовувати обережно, оскільки блокування може призвести до втрати переваг реактивного програмування. У багатьох випадках краще використовувати асинхронні механізми, такі як `subscribe`, або `StepVerifier` для тестування.