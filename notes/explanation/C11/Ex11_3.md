```java
 /**
     * You are implementing time-series database. You need to implement `sum over time` operator. Calculate sum of all
     * metric readings that have been published during one second.
     */
    @Test
    public void sum_over_time() {
        Flux<Long> metrics = metrics()
          .window(Duration.ofSeconds(1))
          .concatMap(window -> window.reduce(0L, Long::sum))
          .doOnNext(sum -> System.out.println("sum last second: " + sum))
          .take(10);


        StepVerifier.create(metrics)
                    .expectNext(45L, 165L, 255L, 396L, 465L, 627L, 675L, 858L, 885L, 1089L)
                    .verifyComplete();
    }
```
### Опис тесту

Тест `sum_over_time()` перевіряє реалізацію оператора `sum over time` для обчислення суми всіх значень метрик, які були опубліковані протягом однієї секунди. Зокрема, тест перевіряє, що суми метрик за кожну секунду правильно обчислюються і відповідають очікуваним результатам.

### Розбір коду

1. **Створення `metrics`**

   ```java
   Flux<Long> metrics = metrics()
       .window(Duration.ofSeconds(1))
       .concatMap(window -> window.reduce(0L, Long::sum))
       .doOnNext(sum -> System.out.println("sum last second: " + sum))
       .take(10);
   ```

    - `metrics()`: Цей метод повертає `Flux` з довільними довільними метриками (числовими значеннями). Ми припускаємо, що цей `Flux` постійно надсилає значення метрик.

    - `.window(Duration.ofSeconds(1))`: Оператор `window` розділяє потік метрик на вікна, що тривають одну секунду. Кожне вікно є новим `Flux`, який містить усі метрики, які надійшли протягом цієї секунди.

    - `.concatMap(window -> window.reduce(0L, Long::sum))`: Оператор `concatMap` використовується для обробки кожного вікна послідовно. `window.reduce(0L, Long::sum)` обчислює суму всіх значень метрик у кожному вікні. `reduce` з початковим значенням `0L` і функцією `Long::sum` додає всі значення в вікні, щоб отримати їхню загальну суму.

    - `.doOnNext(sum -> System.out.println("sum last second: " + sum))`: Оператор `doOnNext` використовується для виведення суми для кожної секунди на консоль. Це допомагає відстежувати, які суми обчислюються.

    - `.take(10)`: Оператор `take(10)` обмежує результуючий `Flux` до перших 10 значень. Це забезпечує, що тест перевіряє лише перші 10 секунд метрик.

2. **Перевірка `metrics`**

   ```java
   StepVerifier.create(metrics)
               .expectNext(45L, 165L, 255L, 396L, 465L, 627L, 675L, 858L, 885L, 1089L)
               .verifyComplete();
   ```

    - `StepVerifier.create(metrics)`: Створює `StepVerifier` для тестування `metrics`.
    - `.expectNext(45L, 165L, 255L, 396L, 465L, 627L, 675L, 858L, 885L, 1089L)`: Перевіряє, що значення, які надходять з `metrics`, відповідають очікуваним сумам за кожну секунду.
    - `.verifyComplete()`: Перевіряє, що `metrics` завершується без помилок після надходження всіх очікуваних значень.

### Пояснення

- **Оператор `window`**: Розділяє потік на вікна по 1 секунді. Це забезпечує створення нових підпотоків (`Flux`) для кожної секунди даних.

- **Оператор `reduce`**: Обчислює суму всіх значень метрик у кожному вікні. Це дозволяє отримати суму метрик за кожну секунду.

- **Оператор `concatMap`**: Обробляє кожне вікно по черзі, що гарантує, що суми обчислюються послідовно, а не паралельно.

- **Оператор `doOnNext`**: Допомагає виводити результати обчислень на консоль для перевірки під час виконання тесту.

- **Оператор `take`**: Обмежує результат до перших 10 значень, що дозволяє контролювати кількість оброблюваних даних.

### Підсумок

Тест `sum_over_time()` перевіряє, що метрики обчислюються у вигляді сум за кожну секунду. Використовуються оператори `window` і `reduce` для досягнення цієї мети. Перевіряється, що суми за кожну секунду відповідають очікуваним результатам, а тест завершується успішно після перевірки перших 10 секунд даних.